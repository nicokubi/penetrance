load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/LiFTUP/Data/PumpkinSpice/processed_pedigree_data_PANC.RData")
dat_adjusted
dat_bc <- read.csv("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/LiFTUP/Data/PumpkinSpice/processed_pedigree_data_PANC.RData")
dat_bc
dat_bc <- load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/LiFTUP/Data/PumpkinSpice/processed_pedigree_data_PANC.RData")
dat_bc
load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/LiFTUP/Data/PumpkinSpice/processed_pedigree_data_PANC.RData")
analyze_missing_ages(dat_bc)
head(dat_adjusted)
load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/LiFTUP/Data/PumpkinSpice/processed_pedigree_data_PANC.RData")
load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/LiFTUP/Data/PumpkinSpice/processed_pedigree_data_PANC.RData")
analyze_missing_ages(dat_adjusted)
library(penetrance)
library(ggplot2)
library(ggridges)
library(ggplot2)
library(dplyr)
library(survival)
library(gridExtra)
library(GGally)
set.seed(2025)
# Load data
dat_original <- read.csv("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/LiFTUP/Data/PumpkinSpice/combined 2.csv")
# Assuming df is your dataframe and variable_name is your column name
value_counts <- table(dat_original$Gender)
print(value_counts)
family_list <- list()
unique_families <- unique(dat_original$Pedigreename)
for (family_id in unique_families) {
family_data <- dat_original[dat_original$Pedigreename == family_id, ]
family_list[[length(family_list) + 1]] <- family_data
}
dat <- family_list
summary(dat_original)
process_pedigree_data <- function(dat) {
###########################################
# USER CONFIGURATION - MODIFY AS NEEDED
###########################################
# Age boundaries
AGE_MIN <- 1    # Minimum valid age
AGE_MAX <- 94   # Maximum valid age
# Column name mapping - modify if your input data has different column names
col_mapping <- c(
"Pedigreename" = "PedigreeID",
"PedigreeIndividualID" = "ID",
"Gender" = "Sex",
"PedigreeMotherID" = "MotherID",
"PedigreeFatherID" = "FatherID",
"probandflag" = "isProband",
"Colorectal" = "isAff",           # Change this for different cancer types
"Colorectal_AgeDx" = "Age",       # Change this for different cancer types
"GT.Pos" = "geno"
)
###########################################
# HELPER FUNCTIONS - DO NOT MODIFY
###########################################
constrain_age <- function(age, min_age = AGE_MIN, max_age = AGE_MAX) {
ifelse(age > max_age, max_age,
ifelse(age < min_age, min_age, age))
}
stats <- list(
removed_sex = 0,
invalid_age = 0,
na_cur_age = 0
)
###########################################
# MAIN PROCESSING LOGIC
###########################################
dat_processed <- lapply(dat, function(df) {
# Rename columns
for (old_name in names(col_mapping)) {
if (old_name %in% colnames(df)) {
colnames(df)[colnames(df) == old_name] <- col_mapping[old_name]
}
}
# Replace CurAge calculation
df$CurAge <- ifelse(!is.na(df$ImputedMortAge),
df$ImputedMortAge,
df$WorkingCensorAge)
# Keep the age constraints
df$CurAge <- constrain_age(df$CurAge)
# Process Sex
initial_rows <- nrow(df)
df$Sex <- ifelse(df$Sex == "M", 1, ifelse(df$Sex == "F", 0, NA))
stats$removed_sex <<- stats$removed_sex + (initial_rows - nrow(df))
# Process binary columns
df$isProband <- ifelse(df$isProband == "proband", 1, 0)
df$isAff[is.na(df$isAff)] <- 0
df$isAff <- ifelse(df$isAff == "True", 1, 0)
df$geno <- ifelse(df$geno == "True", 1,
ifelse(df$geno == "False", 0, NA))
# Process ages
df$CurAge <- constrain_age(df$CurAge)
df$Age <- constrain_age(df$Age)
# Update isAff based on Age
df$isAff <- ifelse(!is.na(df$Age) & df$Age > 0, 1, df$isAff)
# Validate parent IDs
valid_ids <- df$ID
df$FatherID <- ifelse(df$FatherID %in% valid_ids, df$FatherID, NA)
df$MotherID <- ifelse(df$MotherID %in% valid_ids, df$MotherID, NA)
# Handle invalid ages for affected individuals
df$Age[df$isAff == 1 & (is.na(df$Age) | df$Age < AGE_MIN | df$Age > AGE_MAX)] <- NA
# Count NA in CurAge
stats$na_cur_age <<- stats$na_cur_age + sum(is.na(df$CurAge))
# Check for duplicate IDs within this family
duplicate_ids <- df$ID[duplicated(df$ID)]
if (length(duplicate_ids) > 0) {
warning(sprintf("Family %s has duplicate IDs: %s",
df$PedigreeID[1],
paste(duplicate_ids, collapse=", ")))
}
return(df)
})
# Add duplicate count to statistics
stats$families_with_duplicates <- sum(sapply(dat_processed, function(df) {
any(duplicated(df$ID))
}))
list(
processed_data = dat_processed,
statistics = stats
)
}
# Usage
result <- process_pedigree_data(dat)
dat_adjusted <- result$processed_data
# Print statistics
cat(sprintf("Total individuals removed due to missing Sex: %d\n", result$statistics$removed_sex))
cat(sprintf("Total NA values in CurAge: %d\n", result$statistics$na_cur_age))
cat(sprintf("Families with duplicate IDs: %d\n", result$statistics$families_with_duplicates))
#describeFamilies(dat_adjusted)
# Analyze missing age information by relationship to proband
analyze_missing_ages <- function(dat_adjusted) {
# Function to determine relationship to proband
get_relationship_to_proband <- function(df, debug = FALSE) {
proband_row <- which(df$isProband == 1)[1]
if(is.na(proband_row)) return(rep("Unknown", nrow(df)))
relationships <- rep("Unclassified", nrow(df))
relationship_reasons <- rep("", nrow(df))  # For debugging
# First Degree
relationships[df$FatherID == df$ID[proband_row]] <- "1st Degree (Father)"
relationships[df$MotherID == df$ID[proband_row]] <- "1st Degree (Mother)"
relationships[df$FatherID == df$FatherID[proband_row] &
df$MotherID == df$MotherID[proband_row] &
df$ID != df$ID[proband_row]] <- "1st Degree (Sibling)"
relationships[df$FatherID == df$ID[proband_row] |
df$MotherID == df$ID[proband_row]] <- "1st Degree (Child)"
# Second Degree
proband_father_id <- df$FatherID[proband_row]
proband_mother_id <- df$MotherID[proband_row]
# Grandparents
if(!is.na(proband_father_id)) {
relationships[df$FatherID == df$ID[df$ID == proband_father_id]] <- "2nd Degree (Paternal Grandfather)"
relationships[df$MotherID == df$ID[df$ID == proband_father_id]] <- "2nd Degree (Paternal Grandmother)"
}
if(!is.na(proband_mother_id)) {
relationships[df$FatherID == df$ID[df$ID == proband_mother_id]] <- "2nd Degree (Maternal Grandfather)"
relationships[df$MotherID == df$ID[df$ID == proband_mother_id]] <- "2nd Degree (Maternal Grandmother)"
}
# Half-siblings
relationships[df$FatherID == df$FatherID[proband_row] &
df$MotherID != df$MotherID[proband_row] &
df$ID != df$ID[proband_row]] <- "2nd Degree (Paternal Half-Sibling)"
relationships[df$MotherID == df$MotherID[proband_row] &
df$FatherID != df$FatherID[proband_row] &
df$ID != df$ID[proband_row]] <- "2nd Degree (Maternal Half-Sibling)"
# Aunts/Uncles
if(!is.na(proband_father_id)) {
relationships[df$FatherID == df$FatherID[df$ID == proband_father_id] &
df$MotherID == df$MotherID[df$ID == proband_father_id] &
df$ID != proband_father_id] <- "2nd Degree (Paternal Aunt/Uncle)"
}
if(!is.na(proband_mother_id)) {
relationships[df$FatherID == df$FatherID[df$ID == proband_mother_id] &
df$MotherID == df$MotherID[df$ID == proband_mother_id] &
df$ID != proband_mother_id] <- "2nd Degree (Maternal Aunt/Uncle)"
}
# Nieces/Nephews
sibling_ids <- df$ID[df$FatherID == df$FatherID[proband_row] &
df$MotherID == df$MotherID[proband_row] &
df$ID != df$ID[proband_row]]
for(sib_id in sibling_ids) {
relationships[df$FatherID == sib_id | df$MotherID == sib_id] <- "2nd Degree (Niece/Nephew)"
}
# Third Degree
# First cousins
aunt_uncle_ids <- df$ID[grepl("Aunt/Uncle", relationships)]
for(au_id in aunt_uncle_ids) {
relationships[df$FatherID == au_id | df$MotherID == au_id] <- "3rd Degree (First Cousin)"
}
# Great-grandparents
if(!is.na(proband_father_id)) {
father_parents <- df[df$ID == proband_father_id, c("FatherID", "MotherID")]
relationships[df$ID %in% c(df$FatherID[df$ID == father_parents$FatherID],
df$MotherID[df$ID == father_parents$FatherID],
df$FatherID[df$ID == father_parents$MotherID],
df$MotherID[df$ID == father_parents$MotherID])] <- "3rd Degree (Great-Grandparent)"
}
if(!is.na(proband_mother_id)) {
mother_parents <- df[df$ID == proband_mother_id, c("FatherID", "MotherID")]
relationships[df$ID %in% c(df$FatherID[df$ID == mother_parents$FatherID],
df$MotherID[df$ID == mother_parents$FatherID],
df$FatherID[df$ID == mother_parents$MotherID],
df$MotherID[df$ID == mother_parents$MotherID])] <- "3rd Degree (Great-Grandparent)"
}
# Mark proband
relationships[proband_row] <- "Proband"
# Classify any remaining relationships that weren't categorized above
unclassified <- which(relationships == "Unclassified")
if(length(unclassified) > 0) {
for(i in unclassified) {
if(is.na(df$FatherID[i]) && is.na(df$MotherID[i])) {
relationships[i] <- "Other (No Parent Info)"
relationship_reasons[i] <- "Missing parent information"
}
else if(df$ID[i] %in% df$FatherID || df$ID[i] %in% df$MotherID) {
relationships[i] <- "Other (Parent of Non-Proband)"
relationship_reasons[i] <- "Parent of someone other than proband"
}
else {
relationships[i] <- "Other (Distant/Unknown)"
relationship_reasons[i] <- "No clear relationship path to proband"
}
}
}
if(debug) {
return(data.frame(
ID = df$ID,
Relationship = relationships,
Reason = relationship_reasons
))
}
return(relationships)
}
# Apply to each family and combine results
relationship_analysis <- do.call(rbind, lapply(dat_adjusted, function(df) {
relationships <- get_relationship_to_proband(df)
simplified_relationships <- case_when(
relationships == "Proband" ~ "Proband",
grepl("1st Degree", relationships) ~ "First Degree",
grepl("2nd Degree", relationships) ~ "Second Degree",
grepl("3rd Degree", relationships) ~ "Third Degree",
grepl("Other", relationships) ~ relationships,
TRUE ~ relationships
)
data.frame(
Relationship = simplified_relationships,
Missing_CurAge = is.na(df$CurAge),
Missing_Age = is.na(df$Age) & df$isAff == 1
)
}))
# Calculate summary statistics
relationship_summary <- relationship_analysis %>%
group_by(Relationship) %>%
dplyr::summarise(
Total = n(),
Affected = sum(Missing_Age == TRUE | Missing_Age == FALSE),
Missing_CurAge_Count = sum(Missing_CurAge),
Missing_Age_Count = sum(Missing_Age)
) %>%
mutate(
Missing_CurAge_Pct = round(Missing_CurAge_Count / sum(Missing_CurAge_Count) * 100, 1),
Missing_Age_Pct = round(Missing_Age_Count / sum(Missing_Age_Count) * 100, 1)
) %>%
arrange(match(Relationship, c("Proband", "First Degree", "Second Degree", "Third Degree", "Other")))
print(relationship_summary)
# Create visualizations
par(mar = c(10, 4, 4, 2))
# Bar plot for CurAge
barplot(relationship_summary$Missing_CurAge_Pct,
names.arg = paste0(relationship_summary$Relationship, "\n",
relationship_summary$Missing_CurAge_Count, " (",
relationship_summary$Missing_CurAge_Pct, "%)"),
main = "Missing Current Age by Relationship to Proband",
ylab = "Percentage Missing of Total Missing Ages (%)",
las = 2,
cex.names = 0.7)
# Bar plot for Age
barplot(relationship_summary$Missing_Age_Pct,
names.arg = paste0(relationship_summary$Relationship, "\n",
relationship_summary$Missing_Age_Count, " (",
relationship_summary$Missing_Age_Pct, "%)"),
main = "Missing Age of Diagnosis by Relationship to Proband",
ylab = "Percentage Missing of Total Missing Ages (%)",
las = 2,
cex.names = 0.7)
par(mar = c(5, 4, 4, 2))
return(relationship_summary)
}
analyze_missing_ages(dat_adjusted)
load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/LiFTUP/Data/PumpkinSpice/processed_pedigree_data_BC.RData")
analyze_missing_ages(dat_adjusted)
load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/LiFTUP/Data/PumpkinSpice/processed_pedigree_data_PANC.RData")
analyze_missing_ages(dat_adjusted)
load("/Users/nicolaskubista/Partners HealthCare Dropbox/BayesMendel/Projects/Active/NK_PenetranceEstimation/5_Data/PALB2_carrier_families.RData")
analyze_missing_ages(carrier_families_list)
carrier_families_list
dat_original <-carrier_families_list
unique_families <- unique(dat_original$Pedigreename)
for (family_id in unique_families) {
family_data <- dat_original[dat_original$Pedigreename == family_id, ]
family_list[[length(family_list) + 1]] <- family_data
}
dat <- family_list
dat
analyze_missing_ages(dat)
dat <- family_list
analyze_missing_ages(dat)
dat_original <-carrier_families_list
# Usage
result <- process_pedigree_data(carrier_families_list)
devtools::check()
devtools::check_rhub()
devtools::document()
library(penetrance)
load("/Users/nicolaskubista/Documents/Master Statistics/Master Thesis/Code/PenEstim/data/out_sim.RData")
load("/Users/nicolaskubista/Documents/Master Statistics/Master Thesis/Code/PenEstim/data/out_sim.RData")
out_sim$data <- NULL
print(object.size(out_sim), units = "Mb")
load("/Users/nicolaskubista/Documents/Master Statistics/Master Thesis/Code/PenEstim/data/out_sim.RData")
print(object.size(out_sim), units = "Mb")
# Check memory usage in bytes for each element
sizes_bytes <- sapply(my_list, object.size)
print(sizes_bytes)
# Check memory usage in bytes for each element
sizes_bytes <- sapply(out_sim, object.size)
print(sizes_bytes)
out_sim$results <- NULL
save(out_sim, file = "/Users/nicolaskubista/Documents/Master Statistics/Master Thesis/Code/PenEstim/data/out_sim.RData", compress = "xz")
devtools::document()
devtools::document()
devtools::build()
devtools::check()
library(penetrance)
devtools::build()
library(penetrance)
library(ggplot2)
library(ggridges)
library(ggplot2)
library(dplyr)
library(survival)
library(gridExtra)
library(GGally)
source("~/Documents/Master Statistics/Master Thesis/Code/Submission/Additional Scripts/describeFamilies.R")
set.seed(2025)
# Load data
dat_original <- load("/Users/nicolaskubista/Partners HealthCare Dropbox/Nicolas Kubista/CCGCRN Hispanic Cohort Data/PenEstim/Data/geno_cancer_data.RData")
dat <- family_list
for (i in seq_along(dat)) {
# Get all cancer age columns except AgePANC
age_cols <- grep("^Age[A-Z]", colnames(dat[[i]]), value = TRUE)
age_cols <- age_cols[age_cols != "AgePANC"]  # exclude AgePANC
# Find minimum age of any non-PANC cancer
dat[[i]]$MinOtherCancerAge <- do.call(pmin, c(lapply(dat[[i]][age_cols], as.numeric), na.rm = TRUE))
# Set isAff=1 only if pancreatic cancer was first or only cancer
dat[[i]]$isAff <- ifelse(dat[[i]]$isAffPANC == 1 &
(is.na(dat[[i]]$MinOtherCancerAge) |
dat[[i]]$AgePANC <= dat[[i]]$MinOtherCancerAge),
1, 0)
# Ensure no NAs in isAff (convert any NAs to 0)
dat[[i]]$isAff[is.na(dat[[i]]$isAff)] <- 0
# Clean up temporary column
dat[[i]]$MinOtherCancerAge <- NULL
}
for (i in seq_along(dat)) {
if ("AgePANC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgePANC"] <- "Age"
}
}
# Data Preperation in the right format
for (i in seq_along(dat)) {
if ("PedigreeID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
for (i in seq_along(dat)) {
if ("Geno" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "Geno"] <- "geno"
}
}
describeFamilies(dat)
# Use the SEER baseline
baseline <- PPP::PanelPRODatabase$Penetrance["Pancreas","SEER","All_Races",,,"Net"]
# Adjust Format
baseline_df <- as.data.frame(t(baseline))
colnames(baseline_df) <- c("Female", "Male")
baseline_df$Age <- as.numeric(rownames(baseline_df))
baseline_df <- baseline_df[, c("Age","Female", "Male")]
# 1) Define genes of interest
# Genes of interest
target_genes <- c("BRCA1", "BRCA2", "PALB2", "CDKN2A[P16]", "ATM")
# Extract the allele frequency for each gene (e.g., in the 'nonAJ' population)
freq_vec <- sapply(target_genes, function(gene) {
PPP::PanelPRODatabase$AlleleFrequency[paste0(gene, "_anyPV"), "nonAJ"]
})
# Calculate the probability that an individual is NOT a carrier for each gene
# (under the "dominant" assumption => 'not carrier' = (1-p)^2)
not_carrier_vec <- (1 - 2*freq_vec)
# Probability that an individual carries NONE of the 5 variants
prob_none <- prod(not_carrier_vec)
# Probability that an individual carries AT LEAST ONE of the 5 variants
prob_any <- 1 - prob_none
#Run Estimation procedure with default prior setting
system.time(out_Panc_onlyfirst2 <- penetrance(
pedigree  = dat, twins = NULL, n_chains = 1, n_iter_per_chain = 100, ncores = 4, imp_interval = 1,
baseline_data = baseline_df, prev = prob_any,
prior_params = prior_params_default, burn_in = 0.1, median_max = TRUE, thinning_factor = 1,
age_imputation = FALSE, remove_proband = TRUE, sex_specific = TRUE
))
remove.packages("penetrance")
devtools::install()
library(penetrance)
library(ggplot2)
library(ggridges)
library(ggplot2)
library(dplyr)
library(survival)
library(gridExtra)
library(GGally)
source("~/Documents/Master Statistics/Master Thesis/Code/Submission/Additional Scripts/describeFamilies.R")
set.seed(2025)
# Load data
dat_original <- load("/Users/nicolaskubista/Partners HealthCare Dropbox/Nicolas Kubista/CCGCRN Hispanic Cohort Data/PenEstim/Data/geno_cancer_data.RData")
dat <- family_list
library(penetrance)
remove.packages("penetrance")
install.packages("penetrance")
library(penetrance)
devtools::install()
library(penetrance)
library(ggplot2)
library(ggridges)
library(ggplot2)
library(dplyr)
library(survival)
library(gridExtra)
library(GGally)
source("~/Documents/Master Statistics/Master Thesis/Code/Submission/Additional Scripts/describeFamilies.R")
set.seed(2025)
# Load data
dat_original <- load("/Users/nicolaskubista/Partners HealthCare Dropbox/Nicolas Kubista/CCGCRN Hispanic Cohort Data/PenEstim/Data/geno_cancer_data.RData")
dat <- family_list
for (i in seq_along(dat)) {
# Get all cancer age columns except AgePANC
age_cols <- grep("^Age[A-Z]", colnames(dat[[i]]), value = TRUE)
age_cols <- age_cols[age_cols != "AgePANC"]  # exclude AgePANC
# Find minimum age of any non-PANC cancer
dat[[i]]$MinOtherCancerAge <- do.call(pmin, c(lapply(dat[[i]][age_cols], as.numeric), na.rm = TRUE))
# Set isAff=1 only if pancreatic cancer was first or only cancer
dat[[i]]$isAff <- ifelse(dat[[i]]$isAffPANC == 1 &
(is.na(dat[[i]]$MinOtherCancerAge) |
dat[[i]]$AgePANC <= dat[[i]]$MinOtherCancerAge),
1, 0)
# Ensure no NAs in isAff (convert any NAs to 0)
dat[[i]]$isAff[is.na(dat[[i]]$isAff)] <- 0
# Clean up temporary column
dat[[i]]$MinOtherCancerAge <- NULL
}
for (i in seq_along(dat)) {
if ("AgePANC" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "AgePANC"] <- "Age"
}
}
# Data Preperation in the right format
for (i in seq_along(dat)) {
if ("PedigreeID" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "PedigreeID"] <- "FamilyID"
}
}
for (i in seq_along(dat)) {
# Add a new column "PedigreeID" with the list number
dat[[i]]$PedigreeID <- i
}
for (i in seq_along(dat)) {
if ("Geno" %in% colnames(dat[[i]])) {
colnames(dat[[i]])[colnames(dat[[i]]) == "Geno"] <- "geno"
}
}
describeFamilies(dat)
# Use the SEER baseline
baseline <- PPP::PanelPRODatabase$Penetrance["Pancreas","SEER","All_Races",,,"Net"]
# Adjust Format
baseline_df <- as.data.frame(t(baseline))
colnames(baseline_df) <- c("Female", "Male")
baseline_df$Age <- as.numeric(rownames(baseline_df))
baseline_df <- baseline_df[, c("Age","Female", "Male")]
# 1) Define genes of interest
# Genes of interest
target_genes <- c("BRCA1", "BRCA2", "PALB2", "CDKN2A[P16]", "ATM")
# Extract the allele frequency for each gene (e.g., in the 'nonAJ' population)
freq_vec <- sapply(target_genes, function(gene) {
PPP::PanelPRODatabase$AlleleFrequency[paste0(gene, "_anyPV"), "nonAJ"]
})
# Calculate the probability that an individual is NOT a carrier for each gene
# (under the "dominant" assumption => 'not carrier' = (1-p)^2)
not_carrier_vec <- (1 - 2*freq_vec)
# Probability that an individual carries NONE of the 5 variants
prob_none <- prod(not_carrier_vec)
# Probability that an individual carries AT LEAST ONE of the 5 variants
prob_any <- 1 - prob_none
#Run Estimation procedure with default prior setting
system.time(out_Panc_onlyfirst2 <- penetrance(
pedigree  = dat, twins = NULL, n_chains = 1, n_iter_per_chain = 100, ncores = 4, imp_interval = 1,
baseline_data = baseline_df, prev = prob_any,
prior_params = prior_params_default, burn_in = 0.1, median_max = TRUE, thinning_factor = 1,
age_imputation = FALSE, remove_proband = TRUE, sex_specific = TRUE
))
#save(out_Panc_onlyfirst2, file = "out_Panc_onlyfirst.RData2")
devtools::build()
